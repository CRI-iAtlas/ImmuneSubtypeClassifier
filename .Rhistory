return(pair_list)
}
stratified_pair_list <- convert_to_pair_list(top_pairs)
cat("\nStratified cross-platform pair list created:\n")
cat("Length:", length(stratified_pair_list), "(", length(stratified_pair_list)/2, "pairs )\n")
cat("First 10 genes:\n")
print(head(stratified_pair_list, 10))
genes_in_pairs <- unique(stratified_pair_list)
common_genes_check <- setdiff(colnames(train_combined), all_metadata_cols)
missing_genes <- setdiff(genes_in_pairs, common_genes_check)
cat("\nValidation:\n")
cat("Unique genes in pair_list:", length(genes_in_pairs), "\n")
cat("Missing genes:", length(missing_genes), "\n")
if (length(missing_genes) > 0) {
cat("ERROR: These genes are missing:\n")
print(missing_genes)
stop("Fix missing genes before proceeding")
} else {
cat("✓ All genes in pair_list exist in datasets!\n")
}
saveRDS(stratified_pair_list, '../models/pair_list_stratified.rds')
saveRDS(top_pairs, '../models/top_pairs_stratified.rds')
cat("\n=== SAVED FILES ===\n")
cat("✓ Training data: ../data/formatted_full_L1000/train_stratified.csv.gz\n")
cat("   (", nrow(train_combined), "samples:", sum(train_combined$Batch == "EBPP"),
"log2-EBPP +", sum(train_combined$Batch == "Xena_train"), "Xena )\n")
cat("   Columns:", paste(head(colnames(train_combined), 10), collapse=", "), "...\n")
cat("✓ Test data: ../data/formatted_full_L1000/test_xena_holdout.csv.gz\n")
cat("   (", nrow(xena_test), "Xena holdout samples )\n")
cat("   Columns:", paste(head(colnames(xena_test), 10), collapse=", "), "...\n")
cat("✓ Pair list: ../models/pair_list_stratified.rds\n")
cat("✓ Top pairs: ../models/top_pairs_stratified.rds\n")
cat("\n=== SUCCESS ===\n")
cat("EBPP was transformed using Xena's exact method: log2(TPM + 0.001)\n")
cat("Metadata preserved:", paste(final_metadata, collapse=", "), "\n")
cat("Pairs were learned from", nrow(train_combined), "training samples.\n")
cat("These include", sum(train_combined$Batch == "EBPP"), "log2-EBPP +",
sum(train_combined$Batch == "Xena_train"), "Xena samples.\n")
cat("", nrow(xena_test), "Xena samples held out for unbiased testing.\n")
cat("Pairs should be robust across both pipelines!\n")
# Conservative parameters for better C4/C6
conservative_params <- list(
max_depth = 6,
eta = 0.3,
nrounds = 32,
early_stopping_rounds = 2,
gamma = 0.5,
lambda = 2.0,
alpha = 0.5,
ensemble_size = 7,
sample_prop = 0.7,
feature_prop = 0.7,
subsample = 0.7
)
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs.rds',
pair_list = stratified_pair_list,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "Barcode"  # Specify the sample ID column
)
all(colnames(train_combined) == colnames(xena_test))
stratified_pair_list
x <- fread('../data/formatted_full_L1000/training/test_xena_holdout.csv.gz')
all(colnames(train_combined) == colnames(x))
rm(x)
xena_test$Label
xena_test$Barcode
x <- fread('../data/formatted_full_L1000/training/test_xena_holdout.csv.gz')
x$SampleID
train_combined$SampleID
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs.rds',
pair_list = stratified_pair_list,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "SampleID"  # Specify the sample ID column
)
library(data.table)
library(xgboost)
library(ImmuneSubtypeClassifier)
# ============================================================================
# STEP 1: Load cleaned datasets
# ============================================================================
ebpp_clean <- fread('../data/formatted_full_L1000/training/EBpp_pancancer_cleaned.csv.gz')
xena_clean <- fread('../data/formatted_full_L1000/training/xena_rsem_tpm_cleaned.csv.gz')
ebpp_clean$SampleID
rm(xena_clean)
rm(ebpp_clean)
library(ImmuneSubtypeClassifier)
library(ImmuneSubtypeClassifier)
library(data.table)
rsub <- fread('../data/formatted_full_L1000/Rsubread_tpm.csv.gz')
rsub$Barcode
callSubtypes <- function(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid=NULL)
)
callSubtypes <- function(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid=NULL)
)
callSubtypes <- function(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
)
results <- callSubtypes(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid = NULL)
model <- readRDS('model/immune_optimized_pairs.rds')
model$pair_list
results <- callSubtypes(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid = NULL)
results <- callSubtypes(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
save(as.vector(model$pair_list), file = 'data/gene_list.rda')
as.vector(model$pair_list)
pair_list <- as.vector(model$pair_list)
save(pair_list, file = 'data/gene_list.rda')
data(ebpp_gene, envir = environment())
sum(pair_list %in% ebpp_genes_full$Symbol)
sum(! pair_list %in% ebpp_genes_full$Symbol)
pair_list[ (! pair_list %in% ebpp_genes_full$Symbol) ]
ebpp_genes_sig
dim(ebpp_genes_sig)
dim(ebpp_genes_full)
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT-1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1']
pair_list[ (! pair_list %in% ebpp_genes_full$Symbol) ]
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1.1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1-1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1]
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1']
pair_list[ (! pair_list %in% colnames(rsub)) ]
# Check what STAT1 variants exist in rsub
stat1_variants <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub:\n")
print(stat1_variants)
# Check what's in the pair list
stat1_in_pairs <- grep("^STAT1", pair_list, value = TRUE)
cat("\nSTAT1 variants in pair_list:\n")
print(stat1_in_pairs)
# Apply the same normalization used in training data
normalize_gene_names <- function(gene_names) {
gene_names <- gsub(" ", "_", gene_names)
gene_names <- gsub("-", "_", gene_names)
gene_names <- gsub("\\.", "_", gene_names)  # Convert dots to underscores
return(gene_names)
}
# Store original names for reference
rsub_original_names <- colnames(rsub)
# Normalize column names
colnames(rsub) <- normalize_gene_names(colnames(rsub))
# Verify the fix
stat1_after <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub after normalization:\n")
print(stat1_after)
# Should now show: "STAT1" "STAT1_1"
# Final check
missing_genes <- unique(pair_list[!(pair_list %in% colnames(rsub))])
cat("\nMissing genes after normalization:\n")
print(missing_genes)
cat("Count:", length(missing_genes), "\n")
if (length(missing_genes) == 0) {
cat("\n✓ All genes in pair_list now exist in rsub!\n")
} else {
cat("\n✗ Still missing", length(missing_genes), "genes\n")
cat("Examples:", head(missing_genes, 10), "\n")
}
results <- callSubtypes(rsub,
model = model,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
model$predict(
data_frame = rsub,
label_name = 'Label',
sample_id = 'Barcode'
)
results <- callSubtypes(rsub,
model = model,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
results <- model$results()
output <- data.frame(
SampleIDs = results$SampleID,
BestCall = as.integer(gsub("C", "", results$BestCall)),
stringsAsFactors = FALSE
)
View(output)
results
rsub$Label
output <- data.frame(
SampleIDs = results$SampleID,
BestCall = as.integer(gsub("C", "", results$BestCall)),
stringsAsFactors = FALSE
)
table(results$BestCalls, rsub$Label)
labels <- model$test_label
table(results$BestCalls, labels)
table(results$BestCalls, labels)
model$test_label
rsub$Label
model$predict(
data_frame = rsub,
label_name = 'Label',
sample_id = 'Barcode'
)
model$test_label
results <- model$results()
results$Label
results$BestCalls
table(results$BestCalls, results$Label)
score_cols <- grep("^C[1-6]$", colnames(results), value = TRUE)
if (length(score_cols) > 0) {
scores <- results[, score_cols, drop = FALSE]
colnames(scores) <- gsub("C", "", colnames(scores))
scores <- scores[, as.character(1:6)]
output <- cbind(output, scores)
}
score_cols
cat(sprintf("\nConfusion Matrix (%s data):\n", eval_label))
cat(sprintf("\nConfusion Matrix (%s data):\n", ))
print(table(Predicted = results$BestCalls, Actual = model$test_label))
print(model$classification_metrics())
cat(sprintf("\nConfusion Matrix (%s data):\n", 'test'))
print(table(Predicted = results$BestCalls, Actual = model$test_label))
cat("\nClassification Metrics:\n")
print(model$classification_metrics())
conf_matrix <- matrix(c(
1581, 101, 76, 17, 0, 2,
83, 1623, 22, 9, 0, 1,
71, 49, 1752, 40, 4, 10,
46, 41, 69, 588, 13, 4,
0, 0, 3, 9, 357, 0,
14, 17, 21, 1, 0, 56
), nrow=6, byrow=TRUE)
rownames(conf_matrix) <- c("C1", "C2", "C3", "C4", "C5", "C6")
colnames(conf_matrix) <- c("1", "2", "3", "4", "5", "6")
# Calculate per-class metrics
calculate_metrics <- function(conf_mat, class_idx) {
tp <- conf_mat[class_idx, class_idx]
fp <- sum(conf_mat[class_idx, ]) - tp
fn <- sum(conf_mat[, class_idx]) - tp
tn <- sum(conf_mat) - tp - fp - fn
sensitivity <- tp / (tp + fn)
precision <- tp / (tp + fp)
f1 <- 2 * (precision * sensitivity) / (precision + sensitivity)
return(c(Sensitivity=sensitivity, Precision=precision, F1=f1))
}
for (i in 1:6) {
metrics <- calculate_metrics(conf_matrix, i)
cat(sprintf("C%d: Sens=%.3f, Prec=%.3f, F1=%.3f\n",
i, metrics[1], metrics[2], metrics[3]))
}
# Overall accuracy
overall_acc <- sum(diag(conf_matrix)) / sum(conf_matrix)
cat(sprintf("\nOverall Accuracy: %.3f\n", overall_acc))
conf_matrix <- table(Predicted = results$BestCalls, Actual = model$test_label)
rownames(conf_matrix) <- c("C1", "C2", "C3", "C4", "C5", "C6")
colnames(conf_matrix) <- c("1", "2", "3", "4", "5", "6")
# Calculate per-class metrics
calculate_metrics <- function(conf_mat, class_idx) {
tp <- conf_mat[class_idx, class_idx]
fp <- sum(conf_mat[class_idx, ]) - tp
fn <- sum(conf_mat[, class_idx]) - tp
tn <- sum(conf_mat) - tp - fp - fn
sensitivity <- tp / (tp + fn)
precision <- tp / (tp + fp)
f1 <- 2 * (precision * sensitivity) / (precision + sensitivity)
return(c(Sensitivity=sensitivity, Precision=precision, F1=f1))
}
for (i in 1:6) {
metrics <- calculate_metrics(conf_matrix, i)
cat(sprintf("C%d: Sens=%.3f, Prec=%.3f, F1=%.3f\n",
i, metrics[1], metrics[2], metrics[3]))
}
# Overall accuracy
overall_acc <- sum(diag(conf_matrix)) / sum(conf_matrix)
cat(sprintf("\nOverall Accuracy: %.3f\n", overall_acc))
library(data.table)
library(xgboost)
library(ImmuneSubtypeClassifier)
# Conservative parameters for better C4/C6
conservative_params <- list(
max_depth = 8,
eta = 0.3,
nrounds = 64,
early_stopping_rounds = 4,
gamma = 0.2,
lambda = 1.8,
alpha = 0.2,
ensemble_size = 11,
sample_prop = 0.8,
feature_prop = 0.8,
subsample = 0.8
)
stratified_pair_list <- readRDS('../models/pair_list_stratified.rds'))
stratified_pair_list <- readRDS('../models/pair_list_stratified.rds')
this_set <- stratified_pair_list[1:100]
length(this_set)
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs_100.rds',
pair_list = this_set,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "SampleID"  # Specify the sample ID column
)
source("~/Work/imm_sub_pred/ImmuneSubtypeClassifier/test/test_rsubread.R")
model <- readRDS('../models/immune_optimized_pairs_100.rds')
source("~/Work/imm_sub_pred/ImmuneSubtypeClassifier/test/test_rsubread.R")
model$pair_list
model$pair_list
# Apply the same normalization used in training data
normalize_gene_names <- function(gene_names) {
gene_names <- gsub(" ", "_", gene_names)
gene_names <- gsub("-", "_", gene_names)
gene_names <- gsub("\\.", "_", gene_names)  # Convert dots to underscores
return(gene_names)
}
# Store original names for reference
rsub_original_names <- colnames(rsub)
# Normalize column names
colnames(rsub) <- normalize_gene_names(colnames(rsub))
# Verify the fix
stat1_after <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub after normalization:\n")
print(stat1_after)
# Should now show: "STAT1" "STAT1_1"
# Final check
missing_genes <- unique(pair_list[!(pair_list %in% colnames(rsub))])
pair_list <- model$pair_list
# Apply the same normalization used in training data
normalize_gene_names <- function(gene_names) {
gene_names <- gsub(" ", "_", gene_names)
gene_names <- gsub("-", "_", gene_names)
gene_names <- gsub("\\.", "_", gene_names)  # Convert dots to underscores
return(gene_names)
}
# Store original names for reference
rsub_original_names <- colnames(rsub)
# Normalize column names
colnames(rsub) <- normalize_gene_names(colnames(rsub))
# Verify the fix
stat1_after <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub after normalization:\n")
print(stat1_after)
# Final check
missing_genes <- unique(pair_list[!(pair_list %in% colnames(rsub))])
cat("\nMissing genes after normalization:\n")
print(missing_genes)
cat("Count:", length(missing_genes), "\n")
if (length(missing_genes) == 0) {
cat("\n✓ All genes in pair_list now exist in rsub!\n")
} else {
cat("\n✗ Still missing", length(missing_genes), "genes\n")
cat("Examples:", head(missing_genes, 10), "\n")
}
model$predict(
data_frame = rsub,
label_name = 'Label',
sample_id = 'Barcode'
)
results <- model$results()
conf_matrix <- table(Predicted = results$BestCalls, Actual = model$test_label)
rownames(conf_matrix) <- c("C1", "C2", "C3", "C4", "C5", "C6")
colnames(conf_matrix) <- c("1", "2", "3", "4", "5", "6")
# Calculate per-class metrics
calculate_metrics <- function(conf_mat, class_idx) {
tp <- conf_mat[class_idx, class_idx]
fp <- sum(conf_mat[class_idx, ]) - tp
fn <- sum(conf_mat[, class_idx]) - tp
tn <- sum(conf_mat) - tp - fp - fn
sensitivity <- tp / (tp + fn)
precision <- tp / (tp + fp)
f1 <- 2 * (precision * sensitivity) / (precision + sensitivity)
return(c(Sensitivity=sensitivity, Precision=precision, F1=f1))
}
for (i in 1:6) {
metrics <- calculate_metrics(conf_matrix, i)
cat(sprintf("C%d: Sens=%.3f, Prec=%.3f, F1=%.3f\n",
i, metrics[1], metrics[2], metrics[3]))
}
# Overall accuracy
overall_acc <- sum(diag(conf_matrix)) / sum(conf_matrix)
cat(sprintf("\nOverall Accuracy: %.3f\n", overall_acc))
this_set <- stratified_pair_list[1:64]
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs_64.rds',
pair_list = this_set,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "SampleID"  # Specify the sample ID column
)
source("~/Work/imm_sub_pred/ImmuneSubtypeClassifier/test/test_rsubread.R")
renv::activate()
setwd("~/Work/imm_subtype_pred/ImmuneSubtypeClassifier")
renv::install('.')
renv::install('.')
library(ImmuneSubtypeClassifier)
Xs <- readr::read_csv('../data/formatted_full_L1000/xena_rsem_tpm.csv.gz')
result <- callSubtypes(Xs,
model = NULL,
model_path = '../models/immune_optimized_pairs_100.rds',
geneid = "symbol",
sampleid = 'Barcode',
labelid='Label')
renv::install('.')
library(ImmuneSubtypeClassifier)
Xs <- readr::read_csv('../data/formatted_full_L1000/xena_rsem_tpm.csv.gz')
result <- callSubtypes(Xs,
model = NULL,
model_path = '../models/immune_optimized_pairs_100.rds',
geneid = "symbol",
sampleid = 'Barcode',
labelid='Label')
table(result$Label, result$BestCall)
library(caret)
install.packages('caret')
# Create confusion matrix object
cm <- confusionMatrix(
factor(result$BestCall, levels = 1:6),
factor(result$Label, levels = 1:6)
)
library(caret)
# Create confusion matrix object
cm <- confusionMatrix(
factor(result$BestCall, levels = 1:6),
factor(result$Label, levels = 1:6)
)
# Get key metrics
cm$overall  # Overall accuracy, Kappa, etc.
cm$byClass  # Per-class metrics
# Manual calculations:
conf_table <- table(result$Label, result$BestCall)
# 1. Overall Accuracy
accuracy <- sum(diag(conf_table)) / sum(conf_table)
# (1638 + 2371 + 2022 + 856 + 329 + 61) / total ≈ 0.88
# 2. Per-class metrics
per_class <- sapply(1:6, function(i) {
TP <- conf_table[i, i]
FP <- sum(conf_table[, i]) - TP
FN <- sum(conf_table[i, ]) - TP
TN <- sum(conf_table) - TP - FP - FN
precision <- TP / (TP + FP)
recall <- TP / (TP + FN)  # sensitivity
f1 <- 2 * (precision * recall) / (precision + recall)
c(Precision = precision, Recall = recall, F1 = f1)
})
colnames(per_class) <- paste0("Class", 1:6)
t(per_class)
# 3. Macro-averaged F1 (unweighted mean across classes)
macro_f1 <- mean(per_class["F1", ])
# 4. Weighted F1 (weighted by class size)
class_sizes <- rowSums(conf_table)
weighted_f1 <- sum(per_class["F1", ] * class_sizes) / sum(class_sizes)
# 5. Cohen's Kappa (accounts for chance agreement)
kappa <- cm$overall["Kappa"]
# Quick summary
list(
Accuracy = accuracy,
Macro_F1 = macro_f1,
Weighted_F1 = weighted_f1,
Kappa = kappa
)
stratified_pair_list <- readRDS('../models/pair_list_stratified.rds')
this_set <- stratified_pair_list[1:64]
new_list <- editPairList(this_set, 'IGJ')
