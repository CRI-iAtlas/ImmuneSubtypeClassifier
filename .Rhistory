data = as.matrix(pair_data[train_idx, ]),
label = labels_numeric[train_idx]
)
dval <- xgb.DMatrix(
data = as.matrix(pair_data[val_idx, ]),
label = labels_numeric[val_idx]
)
params <- list(
objective = "multi:softmax",
num_class = num_classes,
max_depth = 4,
eta = 0.3,
subsample = 0.8,
colsample_bytree = 0.8,
eval_metric = "mlogloss"
)
watchlist <- list(train = dtrain, val = dval)
xgb_model <- xgb.train(
params = params,
data = dtrain,
nrounds = nrounds,
watchlist = watchlist,
early_stopping_rounds = early_stopping,
verbose = 1
)
importance_matrix <- xgb.importance(
feature_names = colnames(pair_data),
model = xgb_model
)
importance_matrix$gene1 <- sapply(strsplit(importance_matrix$Feature, "_X_"), `[`, 1)
importance_matrix$gene2 <- sapply(strsplit(importance_matrix$Feature, "_X_"), `[`, 2)
top_pairs <- head(importance_matrix, top_n)
cat(sprintf("\nTop %d pairs selected from %d total\n",
nrow(top_pairs), nrow(importance_matrix)))
cat(sprintf("Top pair: %s (importance: %.4f)\n",
top_pairs$Feature[1], top_pairs$Gain[1]))
return(top_pairs)
}
# Learn pairs from training data (log-EBPP + 50% Xena)
cat("=== Learning pairs from STRATIFIED TRAINING SET ===\n")
cat("Training on:", nrow(train_combined), "samples (log2-EBPP + 50% Xena)\n")
cat("Held out:", nrow(xena_test), "samples (50% Xena for testing)\n\n")
gc()
object.size(train_combined)
object.size(train_combined, units = "MB")
print(object.size(train_combined), units = "MB")
print(object.size(all_pairs_train), units = "MB")
# Include hidden objects (starting with .)
all_objs <- ls(all.names = TRUE)
sizes <- sapply(all_objs, function(x) object.size(get(x)))
sort(sizes, decreasing = TRUE)[1:20]  # Top 20
# Or get total
sum(sizes) / 1024^3  # In GB
# What R thinks it's using
gc()  # Look at the "max used" columns
# System view
library(pryr)
install.packages('pryr')
gc(full = TRUE)
top_pairs <- rank_pairs_xgboost(
pair_data = all_pairs_train,
labels = train_combined$Label,
top_n = 100,
nrounds = 50,
early_stopping = 5
)
rm(all_pairs_train)
gc()
convert_to_pair_list <- function(ranked_pairs) {
pair_list <- c()
for (i in 1:nrow(ranked_pairs)) {
pair_list <- c(pair_list, ranked_pairs$gene1[i], ranked_pairs$gene2[i])
}
return(pair_list)
}
stratified_pair_list <- convert_to_pair_list(top_pairs)
cat("\nStratified cross-platform pair list created:\n")
cat("Length:", length(stratified_pair_list), "(", length(stratified_pair_list)/2, "pairs )\n")
cat("First 10 genes:\n")
print(head(stratified_pair_list, 10))
genes_in_pairs <- unique(stratified_pair_list)
common_genes_check <- setdiff(colnames(train_combined), all_metadata_cols)
missing_genes <- setdiff(genes_in_pairs, common_genes_check)
cat("\nValidation:\n")
cat("Unique genes in pair_list:", length(genes_in_pairs), "\n")
cat("Missing genes:", length(missing_genes), "\n")
if (length(missing_genes) > 0) {
cat("ERROR: These genes are missing:\n")
print(missing_genes)
stop("Fix missing genes before proceeding")
} else {
cat("✓ All genes in pair_list exist in datasets!\n")
}
saveRDS(stratified_pair_list, '../models/pair_list_stratified.rds')
saveRDS(top_pairs, '../models/top_pairs_stratified.rds')
cat("\n=== SAVED FILES ===\n")
cat("✓ Training data: ../data/formatted_full_L1000/train_stratified.csv.gz\n")
cat("   (", nrow(train_combined), "samples:", sum(train_combined$Batch == "EBPP"),
"log2-EBPP +", sum(train_combined$Batch == "Xena_train"), "Xena )\n")
cat("   Columns:", paste(head(colnames(train_combined), 10), collapse=", "), "...\n")
cat("✓ Test data: ../data/formatted_full_L1000/test_xena_holdout.csv.gz\n")
cat("   (", nrow(xena_test), "Xena holdout samples )\n")
cat("   Columns:", paste(head(colnames(xena_test), 10), collapse=", "), "...\n")
cat("✓ Pair list: ../models/pair_list_stratified.rds\n")
cat("✓ Top pairs: ../models/top_pairs_stratified.rds\n")
cat("\n=== SUCCESS ===\n")
cat("EBPP was transformed using Xena's exact method: log2(TPM + 0.001)\n")
cat("Metadata preserved:", paste(final_metadata, collapse=", "), "\n")
cat("Pairs were learned from", nrow(train_combined), "training samples.\n")
cat("These include", sum(train_combined$Batch == "EBPP"), "log2-EBPP +",
sum(train_combined$Batch == "Xena_train"), "Xena samples.\n")
cat("", nrow(xena_test), "Xena samples held out for unbiased testing.\n")
cat("Pairs should be robust across both pipelines!\n")
# Conservative parameters for better C4/C6
conservative_params <- list(
max_depth = 6,
eta = 0.3,
nrounds = 32,
early_stopping_rounds = 2,
gamma = 0.5,
lambda = 2.0,
alpha = 0.5,
ensemble_size = 7,
sample_prop = 0.7,
feature_prop = 0.7,
subsample = 0.7
)
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs.rds',
pair_list = stratified_pair_list,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "Barcode"  # Specify the sample ID column
)
all(colnames(train_combined) == colnames(xena_test))
stratified_pair_list
x <- fread('../data/formatted_full_L1000/training/test_xena_holdout.csv.gz')
all(colnames(train_combined) == colnames(x))
rm(x)
xena_test$Label
xena_test$Barcode
x <- fread('../data/formatted_full_L1000/training/test_xena_holdout.csv.gz')
x$SampleID
train_combined$SampleID
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs.rds',
pair_list = stratified_pair_list,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "SampleID"  # Specify the sample ID column
)
library(data.table)
library(xgboost)
library(ImmuneSubtypeClassifier)
# ============================================================================
# STEP 1: Load cleaned datasets
# ============================================================================
ebpp_clean <- fread('../data/formatted_full_L1000/training/EBpp_pancancer_cleaned.csv.gz')
xena_clean <- fread('../data/formatted_full_L1000/training/xena_rsem_tpm_cleaned.csv.gz')
ebpp_clean$SampleID
rm(xena_clean)
rm(ebpp_clean)
library(ImmuneSubtypeClassifier)
library(ImmuneSubtypeClassifier)
library(data.table)
rsub <- fread('../data/formatted_full_L1000/Rsubread_tpm.csv.gz')
rsub$Barcode
callSubtypes <- function(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid=NULL)
)
callSubtypes <- function(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid=NULL)
)
callSubtypes <- function(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
)
results <- callSubtypes(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid = NULL)
model <- readRDS('model/immune_optimized_pairs.rds')
model$pair_list
results <- callSubtypes(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode',
labelid = NULL)
results <- callSubtypes(rsub,
model = NULL,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
save(as.vector(model$pair_list), file = 'data/gene_list.rda')
as.vector(model$pair_list)
pair_list <- as.vector(model$pair_list)
save(pair_list, file = 'data/gene_list.rda')
data(ebpp_gene, envir = environment())
sum(pair_list %in% ebpp_genes_full$Symbol)
sum(! pair_list %in% ebpp_genes_full$Symbol)
pair_list[ (! pair_list %in% ebpp_genes_full$Symbol) ]
ebpp_genes_sig
dim(ebpp_genes_sig)
dim(ebpp_genes_full)
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT-1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1']
pair_list[ (! pair_list %in% ebpp_genes_full$Symbol) ]
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1.1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1-1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1']
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1]
ebpp_genes_full[ebpp_genes_full$Symbol == 'STAT1']
pair_list[ (! pair_list %in% colnames(rsub)) ]
# Check what STAT1 variants exist in rsub
stat1_variants <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub:\n")
print(stat1_variants)
# Check what's in the pair list
stat1_in_pairs <- grep("^STAT1", pair_list, value = TRUE)
cat("\nSTAT1 variants in pair_list:\n")
print(stat1_in_pairs)
# Apply the same normalization used in training data
normalize_gene_names <- function(gene_names) {
gene_names <- gsub(" ", "_", gene_names)
gene_names <- gsub("-", "_", gene_names)
gene_names <- gsub("\\.", "_", gene_names)  # Convert dots to underscores
return(gene_names)
}
# Store original names for reference
rsub_original_names <- colnames(rsub)
# Normalize column names
colnames(rsub) <- normalize_gene_names(colnames(rsub))
# Verify the fix
stat1_after <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub after normalization:\n")
print(stat1_after)
# Should now show: "STAT1" "STAT1_1"
# Final check
missing_genes <- unique(pair_list[!(pair_list %in% colnames(rsub))])
cat("\nMissing genes after normalization:\n")
print(missing_genes)
cat("Count:", length(missing_genes), "\n")
if (length(missing_genes) == 0) {
cat("\n✓ All genes in pair_list now exist in rsub!\n")
} else {
cat("\n✗ Still missing", length(missing_genes), "genes\n")
cat("Examples:", head(missing_genes, 10), "\n")
}
results <- callSubtypes(rsub,
model = model,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
model$predict(
data_frame = rsub,
label_name = 'Label',
sample_id = 'Barcode'
)
results <- callSubtypes(rsub,
model = model,
model_path = NULL,
geneid = "symbol",
sampleid = 'Barcode')
results <- model$results()
output <- data.frame(
SampleIDs = results$SampleID,
BestCall = as.integer(gsub("C", "", results$BestCall)),
stringsAsFactors = FALSE
)
View(output)
results
rsub$Label
output <- data.frame(
SampleIDs = results$SampleID,
BestCall = as.integer(gsub("C", "", results$BestCall)),
stringsAsFactors = FALSE
)
table(results$BestCalls, rsub$Label)
labels <- model$test_label
table(results$BestCalls, labels)
table(results$BestCalls, labels)
model$test_label
rsub$Label
model$predict(
data_frame = rsub,
label_name = 'Label',
sample_id = 'Barcode'
)
model$test_label
results <- model$results()
results$Label
results$BestCalls
table(results$BestCalls, results$Label)
score_cols <- grep("^C[1-6]$", colnames(results), value = TRUE)
if (length(score_cols) > 0) {
scores <- results[, score_cols, drop = FALSE]
colnames(scores) <- gsub("C", "", colnames(scores))
scores <- scores[, as.character(1:6)]
output <- cbind(output, scores)
}
score_cols
cat(sprintf("\nConfusion Matrix (%s data):\n", eval_label))
cat(sprintf("\nConfusion Matrix (%s data):\n", ))
print(table(Predicted = results$BestCalls, Actual = model$test_label))
print(model$classification_metrics())
cat(sprintf("\nConfusion Matrix (%s data):\n", 'test'))
print(table(Predicted = results$BestCalls, Actual = model$test_label))
cat("\nClassification Metrics:\n")
print(model$classification_metrics())
conf_matrix <- matrix(c(
1581, 101, 76, 17, 0, 2,
83, 1623, 22, 9, 0, 1,
71, 49, 1752, 40, 4, 10,
46, 41, 69, 588, 13, 4,
0, 0, 3, 9, 357, 0,
14, 17, 21, 1, 0, 56
), nrow=6, byrow=TRUE)
rownames(conf_matrix) <- c("C1", "C2", "C3", "C4", "C5", "C6")
colnames(conf_matrix) <- c("1", "2", "3", "4", "5", "6")
# Calculate per-class metrics
calculate_metrics <- function(conf_mat, class_idx) {
tp <- conf_mat[class_idx, class_idx]
fp <- sum(conf_mat[class_idx, ]) - tp
fn <- sum(conf_mat[, class_idx]) - tp
tn <- sum(conf_mat) - tp - fp - fn
sensitivity <- tp / (tp + fn)
precision <- tp / (tp + fp)
f1 <- 2 * (precision * sensitivity) / (precision + sensitivity)
return(c(Sensitivity=sensitivity, Precision=precision, F1=f1))
}
for (i in 1:6) {
metrics <- calculate_metrics(conf_matrix, i)
cat(sprintf("C%d: Sens=%.3f, Prec=%.3f, F1=%.3f\n",
i, metrics[1], metrics[2], metrics[3]))
}
# Overall accuracy
overall_acc <- sum(diag(conf_matrix)) / sum(conf_matrix)
cat(sprintf("\nOverall Accuracy: %.3f\n", overall_acc))
conf_matrix <- table(Predicted = results$BestCalls, Actual = model$test_label)
rownames(conf_matrix) <- c("C1", "C2", "C3", "C4", "C5", "C6")
colnames(conf_matrix) <- c("1", "2", "3", "4", "5", "6")
# Calculate per-class metrics
calculate_metrics <- function(conf_mat, class_idx) {
tp <- conf_mat[class_idx, class_idx]
fp <- sum(conf_mat[class_idx, ]) - tp
fn <- sum(conf_mat[, class_idx]) - tp
tn <- sum(conf_mat) - tp - fp - fn
sensitivity <- tp / (tp + fn)
precision <- tp / (tp + fp)
f1 <- 2 * (precision * sensitivity) / (precision + sensitivity)
return(c(Sensitivity=sensitivity, Precision=precision, F1=f1))
}
for (i in 1:6) {
metrics <- calculate_metrics(conf_matrix, i)
cat(sprintf("C%d: Sens=%.3f, Prec=%.3f, F1=%.3f\n",
i, metrics[1], metrics[2], metrics[3]))
}
# Overall accuracy
overall_acc <- sum(diag(conf_matrix)) / sum(conf_matrix)
cat(sprintf("\nOverall Accuracy: %.3f\n", overall_acc))
library(data.table)
library(xgboost)
library(ImmuneSubtypeClassifier)
# Conservative parameters for better C4/C6
conservative_params <- list(
max_depth = 8,
eta = 0.3,
nrounds = 64,
early_stopping_rounds = 4,
gamma = 0.2,
lambda = 1.8,
alpha = 0.2,
ensemble_size = 11,
sample_prop = 0.8,
feature_prop = 0.8,
subsample = 0.8
)
stratified_pair_list <- readRDS('../models/pair_list_stratified.rds'))
stratified_pair_list <- readRDS('../models/pair_list_stratified.rds')
this_set <- stratified_pair_list[1:100]
length(this_set)
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs_100.rds',
pair_list = this_set,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "SampleID"  # Specify the sample ID column
)
source("~/Work/imm_sub_pred/ImmuneSubtypeClassifier/test/test_rsubread.R")
model <- readRDS('../models/immune_optimized_pairs_100.rds')
source("~/Work/imm_sub_pred/ImmuneSubtypeClassifier/test/test_rsubread.R")
model$pair_list
model$pair_list
# Apply the same normalization used in training data
normalize_gene_names <- function(gene_names) {
gene_names <- gsub(" ", "_", gene_names)
gene_names <- gsub("-", "_", gene_names)
gene_names <- gsub("\\.", "_", gene_names)  # Convert dots to underscores
return(gene_names)
}
# Store original names for reference
rsub_original_names <- colnames(rsub)
# Normalize column names
colnames(rsub) <- normalize_gene_names(colnames(rsub))
# Verify the fix
stat1_after <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub after normalization:\n")
print(stat1_after)
# Should now show: "STAT1" "STAT1_1"
# Final check
missing_genes <- unique(pair_list[!(pair_list %in% colnames(rsub))])
pair_list <- model$pair_list
# Apply the same normalization used in training data
normalize_gene_names <- function(gene_names) {
gene_names <- gsub(" ", "_", gene_names)
gene_names <- gsub("-", "_", gene_names)
gene_names <- gsub("\\.", "_", gene_names)  # Convert dots to underscores
return(gene_names)
}
# Store original names for reference
rsub_original_names <- colnames(rsub)
# Normalize column names
colnames(rsub) <- normalize_gene_names(colnames(rsub))
# Verify the fix
stat1_after <- grep("^STAT1", colnames(rsub), value = TRUE)
cat("STAT1 variants in rsub after normalization:\n")
print(stat1_after)
# Final check
missing_genes <- unique(pair_list[!(pair_list %in% colnames(rsub))])
cat("\nMissing genes after normalization:\n")
print(missing_genes)
cat("Count:", length(missing_genes), "\n")
if (length(missing_genes) == 0) {
cat("\n✓ All genes in pair_list now exist in rsub!\n")
} else {
cat("\n✗ Still missing", length(missing_genes), "genes\n")
cat("Examples:", head(missing_genes, 10), "\n")
}
model$predict(
data_frame = rsub,
label_name = 'Label',
sample_id = 'Barcode'
)
results <- model$results()
conf_matrix <- table(Predicted = results$BestCalls, Actual = model$test_label)
rownames(conf_matrix) <- c("C1", "C2", "C3", "C4", "C5", "C6")
colnames(conf_matrix) <- c("1", "2", "3", "4", "5", "6")
# Calculate per-class metrics
calculate_metrics <- function(conf_mat, class_idx) {
tp <- conf_mat[class_idx, class_idx]
fp <- sum(conf_mat[class_idx, ]) - tp
fn <- sum(conf_mat[, class_idx]) - tp
tn <- sum(conf_mat) - tp - fp - fn
sensitivity <- tp / (tp + fn)
precision <- tp / (tp + fp)
f1 <- 2 * (precision * sensitivity) / (precision + sensitivity)
return(c(Sensitivity=sensitivity, Precision=precision, F1=f1))
}
for (i in 1:6) {
metrics <- calculate_metrics(conf_matrix, i)
cat(sprintf("C%d: Sens=%.3f, Prec=%.3f, F1=%.3f\n",
i, metrics[1], metrics[2], metrics[3]))
}
# Overall accuracy
overall_acc <- sum(diag(conf_matrix)) / sum(conf_matrix)
cat(sprintf("\nOverall Accuracy: %.3f\n", overall_acc))
this_set <- stratified_pair_list[1:64]
# Now use the cleaned pair_list
result <- build_robencla_classifier(
data_path='../data/formatted_full_L1000/training/combined_ebpp_xena.csv.gz',
test_path='../data/formatted_full_L1000/training/test_xena_holdout.csv.gz',
output_path = '../models/immune_optimized_pairs_64.rds',
pair_list = this_set,
sig_list = NULL,
param_list = conservative_params,
data_mode = c("namedpairs"),
train_fraction = NULL,
seed = 412,
sample_id = "SampleID"  # Specify the sample ID column
)
source("~/Work/imm_sub_pred/ImmuneSubtypeClassifier/test/test_rsubread.R")
